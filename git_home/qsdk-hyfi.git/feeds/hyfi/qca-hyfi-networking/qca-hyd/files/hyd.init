#!/bin/sh /etc/rc.common
# Copyright (c) 2013 Qualcomm Atheros, Inc.
#
# All Rights Reserved.
# Qualcomm Atheros Confidential and Proprietary. 

START=96
SERVICE_WRITE_PID=1
SERVICE_DAEMONIZE=1
SERVICE_DEBUG_OUTPUT=0
SERVICE_PATH="/usr/sbin/hyd"
HYD_CONFIG_FILE="/tmp/hyd.conf"
HYD_RUN_FILE="/var/run/.hyd"
ECM_SYSFS_FILE="/sys/kernel/debug/ecm/ecm_classifier_hyfi/enabled"

# The stop_wifidown command is a special command that does not try to do
# any locking in order to prevent deadlocks during a wifi down operation
# that is actually part of a Wi-Fi interface restart.
EXTRA_COMMANDS="stop_wifidown"
EXTRA_HELP=<<EOF
	stop_wifidown Stop hyd while bring down Wi-Fi interfaces
EOF

local ieee1905managed_bridge

. /lib/functions/hyfi-debug.sh
. /lib/functions/hyfi-iface.sh
. /lib/functions/hyfi-network.sh

if [ -f /lib/functions/lbd-config.sh ]; then
    . /lib/functions/lbd-config.sh
fi

__hyd_cfg_append() {
	echo "$1" >> "$HYD_CONFIG_FILE"
}

__hyd_cfg_nl_append() {
	echo "" >> "$HYD_CONFIG_FILE"
	echo "$1" >> "$HYD_CONFIG_FILE"
}

# __hyd_cfg_add_str <section> <option>
__hyd_cfg_add_str() {
	local key="$2"
	local section="$1"
	local option="$2"

	config_get val "${section}" "${option}"
	[ -n "${val}" ] && __hyd_cfg_append "${key}=${val}"
}

__hyd_get_default_mode() {

	local mode=$(artmtd -r board_model_id)

	if [ "$mode" = "model_id:RBS50" ] ;then
		eval "$1='HYCLIENT'"
		uci set hyd.config.Mode=HYCLIENT
		uci commit hyd
	elif [ "$mode" = "model_id:RBR50" ] ;then
		eval "$1='HYROUTER'"
		uci set hyd.config.Mode=HYROUTER
		uci commit hyd
	fi
}

__hyd_get_wlan_sta_ifaces() {
	local config="$1"
	local iface network mode

	config_get iface "$config" ifname
	config_get network "$config" network
	config_get mode "$config" mode

	if [ "$2" = "$network" -a "$mode" = "sta" ]; then
		non_relay_ifaces=${non_relay_ifaces}${non_relay_ifaces:+","}${iface}
	fi
}

__hyd_cfg_add_interface() {
	local all_ifaces wlan_ifaces plc_iface non_relay_ifaces default_mode

	__hyd_cfg_append 'HybridBridgeInterfaceName=br'$ieee1905managed_bridge

	# Get a list of all interfaces
	hyfi_get_ifaces $ieee1905managed_bridge all_ifaces
	__hyd_cfg_append 'ManagedInterfacesList='$all_ifaces

	__hyd_get_default_mode default_mode
	config_get mode config 'Mode' $default_mode

	if [ "${mode}" = 'HYCLIENT' ];then
		# Get PLC interface
		hyfi_get_plc_iface $ieee1905managed_bridge plc_iface
		if [ -n "$plc_iface" ]; then
			hyfi_strip_list $plc_iface plc_iface
			non_relay_ifaces=$plc_iface
		fi

		# Get all WLAN interfaces bound to the managed bridge
		config_load wireless
		config_foreach __hyd_get_wlan_sta_ifaces wifi-iface $ieee1905managed_bridge

		__hyd_cfg_append	'NoRelayGroupList='"$non_relay_ifaces"
		__hyd_cfg_append	'ForceGroupRelaying=1'
	fi

	local switch_lan_vid
	local switch_cpu_root_port

	__hyfi_get_switch_lan_vid switch_lan_vid
	__hyfi_get_switch_cpu_port switch_cpu_root_port
	__hyd_cfg_append 'SwitchLanVid='"$switch_lan_vid"
	__hyd_cfg_append 'SwitchCpuPort='"$switch_cpu_root_port"
}

__hyd_cfg_add_head() {
	echo ";"	> "$HYD_CONFIG_FILE"
	__hyd_cfg_append ';  Automatically generated hyd configure file,do not change it.'
	__hyd_cfg_append ';'
	__hyd_cfg_append ';  INTERFACE:       interface manager'
	__hyd_cfg_append ';  HY:              hy manager'
	__hyd_cfg_append ';  WLAN:            wlan manager'
	__hyd_cfg_append ';  PLC:             plc manager'
	__hyd_cfg_append ';  ETH:             eth manager'
	__hyd_cfg_append ';  PATHCH:          pc service'
	__hyd_cfg_append ';  PATHCHWLAN:      pcw service'
	__hyd_cfg_append ';  PATHCHPLC:       pcp service'
	__hyd_cfg_append ';  PATHCHETH:       pce service'
	__hyd_cfg_append ';  TOPOLOGY:        td service'
	__hyd_cfg_append ';  HSPECEST:        he service'
	__hyd_cfg_append ';  PATHSELECT:      ps service'
	__hyd_cfg_append ';  LOGSETTINGS:     log service'
	__hyd_cfg_append ';  IEEE1905:        IEEE 1905.1 settings'
	__hyd_cfg_append ';  HCP:             HCP settings'
	__hyd_cfg_append ';'
}

__hyd_create_config() {
	config_load 'hyd'
	__hyd_cfg_add_head

	__hyd_cfg_nl_append '[INTERFACE]'
	__hyd_cfg_add_interface

	__hyd_cfg_nl_append '[HY]'
	__hyd_cfg_add_str 	hy			ExtraQueryResponseTime
	__hyd_cfg_add_str		hy			LoadBalancingSeamless
	__hyd_cfg_add_str		hy			ConstrainTCPMedium
	__hyd_cfg_add_str		hy			MaxLBReordTimeout
	__hyd_cfg_add_str		hy			PathTransitionMethod

	__hyd_cfg_nl_append '[PATHCHWLAN]'
	__hyd_cfg_add_str		PathChWlan		UpdatedStatsInterval_W2
	__hyd_cfg_add_str		PathChWlan		StatsAgedOutInterval_W2
	__hyd_cfg_add_str		PathChWlan		MaxMediumUtilization_W2
	__hyd_cfg_add_str		PathChWlan		MediumChangeThreshold_W2
	__hyd_cfg_add_str		PathChWlan		LinkChangeThreshold_W2
	__hyd_cfg_add_str		PathChWlan		MaxMediumUtilizationForLC_W2
	__hyd_cfg_add_str		PathChWlan		CPULimitedTCPThroughput_W2
	__hyd_cfg_add_str		PathChWlan		CPULimitedUDPThroughput_W2
	__hyd_cfg_add_str		PathChWlan		PHYRateThresholdForMU_W2
	__hyd_cfg_add_str		PathChWlan		ProbePacketInterval_W2
	__hyd_cfg_add_str		PathChWlan		ProbePacketSize_W2
	__hyd_cfg_add_str		PathChWlan		EnableProbe_W2
	__hyd_cfg_add_str		PathChWlan		AssocDetectionDelay_W2
	__hyd_cfg_add_str		PathChWlan		UpdatedStatsInterval_W5
	__hyd_cfg_add_str		PathChWlan		StatsAgedOutInterval_W5
	__hyd_cfg_add_str		PathChWlan		MaxMediumUtilization_W5
	__hyd_cfg_add_str		PathChWlan		MediumChangeThreshold_W5
	__hyd_cfg_add_str		PathChWlan		LinkChangeThreshold_W5
	__hyd_cfg_add_str		PathChWlan		MaxMediumUtilizationForLC_W5
	__hyd_cfg_add_str		PathChWlan		CPULimitedTCPThroughput_W5
	__hyd_cfg_add_str		PathChWlan		CPULimitedUDPThroughput_W5
	__hyd_cfg_add_str		PathChWlan		PHYRateThresholdForMU_W5
	__hyd_cfg_add_str		PathChWlan		ProbePacketInterval_W5
	__hyd_cfg_add_str		PathChWlan		ProbePacketSize_W5
	__hyd_cfg_add_str		PathChWlan		EnableProbe_W5
	__hyd_cfg_add_str		PathChWlan		AssocDetectionDelay_W5
	__hyd_cfg_add_str		PathSelect		LinkCapacityThreshold
	__hyd_cfg_add_str		PathChWlan		ScalingFactorHighRate_W5
	__hyd_cfg_add_str		PathChWlan		ScalingFactorHighRate_W2
	__hyd_cfg_add_str		PathChWlan		ScalingFactorLow
	__hyd_cfg_add_str		PathChWlan		ScalingFactorMedium
	__hyd_cfg_add_str		PathChWlan		ScalingFactorHigh
	__hyd_cfg_add_str		PathChWlan		ScalingFactorTCP
	__hyd_cfg_add_str		PathChWlan		UseWHCAlgorithm

	__hyd_cfg_nl_append '[PATHCHPLC]'
	__hyd_cfg_add_str		PathChPlc		MaxMediumUtilization
	__hyd_cfg_add_str		PathChPlc		MediumChangeThreshold
	__hyd_cfg_add_str		PathChPlc		LinkChangeThreshold
	__hyd_cfg_add_str		PathChPlc		StatsAgedOutInterval
	__hyd_cfg_add_str		PathChPlc		UpdateStatsInterval
	__hyd_cfg_add_str		PathChPlc		EntryExpirationInterval
	__hyd_cfg_add_str		PathChPlc		MaxMediumUtilizationForLC
	__hyd_cfg_add_str		PathChPlc		LCThresholdForUnreachable
	__hyd_cfg_add_str		PathChPlc		LCThresholdForReachable
	__hyd_cfg_add_str		PathChPlc		HostPLCInterfaceSpeed

	__hyd_cfg_nl_append '[TOPOLOGY]'
	__hyd_cfg_add_str		Topology		ND_UPDATE_INTERVA
	__hyd_cfg_add_str		Topology		BD_UPDATE_INTERVAL
	__hyd_cfg_add_str		Topology		HOLDING_TIME
	__hyd_cfg_add_str		Topology		TIMER_LOW_BOUND
	__hyd_cfg_add_str		Topology		TIMER_UPPER_BOUND
	__hyd_cfg_add_str		Topology		MSGID_DELTA
	__hyd_cfg_add_str		Topology		HA_AGING_INTERVAL
	__hyd_cfg_add_str		Topology		ENABLE_TD3
	__hyd_cfg_add_str		Topology		ENABLE_BD_SPOOFING
	__hyd_cfg_add_str		Topology		NOTIFICATION_THROTTLING_WINDOW

	__hyd_cfg_nl_append '[PATHSELECT]'
	__hyd_cfg_add_str		PathSelect		UpdateHDInterval
	__hyd_cfg_add_str		PathSelect		LinkCapacityThreshold
	__hyd_cfg_add_str		PathSelect		UDPInterfaceOrder
	__hyd_cfg_add_str		PathSelect		NonUDPInterfaceOrder
	__hyd_cfg_add_str		PathSelect		SerialflowIterations
	__hyd_cfg_add_str		PathSelect		DeltaLCThreshold

	__hyd_cfg_nl_append '[HSPECEST]'
	__hyd_cfg_add_str		HSPECEst		UpdateHSPECInterval
	__hyd_cfg_add_str		HSPECEst		NotificationThresholdLimit
	__hyd_cfg_add_str		HSPECEst		NotificationThresholdPercentage
	__hyd_cfg_add_str		HSPECEst		AlphaNumerator
	__hyd_cfg_add_str		HSPECEst		AlphaDenominator
	__hyd_cfg_add_str		HSPECEst		BufferAllocationThresholdLow
	__hyd_cfg_add_str		HSPECEst		BufferAllocationThresholdHigh
	__hyd_cfg_add_str		HSPECEst		MaxTrackedFlows
	__hyd_cfg_add_str		HSPECEst		ReservedMemory
	__hyd_cfg_add_str		HSPECEst		LocalFlowRateThreshold
	__hyd_cfg_add_str		HSPECEst		LocalFlowRatioThreshold
	__hyd_cfg_add_str		HSPECEst		MaxHActiveEntries

	__hyd_cfg_nl_append '[LOGSETTINGS]'
	__hyd_cfg_add_str		LogSettings		EnableLog
	__hyd_cfg_add_str		LogSettings		LogRestartIntervalSec
	__hyd_cfg_add_str		LogSettings		LogPCSummaryIntervalSec
	__hyd_cfg_add_str		LogSettings		LogServerIP
	__hyd_cfg_add_str		LogSettings		LogServerPort
	__hyd_cfg_add_str		LogSettings		EnableLogPCW2
	__hyd_cfg_add_str		LogSettings		EnableLogPCW5
	__hyd_cfg_add_str		LogSettings		EnableLogPCP
	__hyd_cfg_add_str		LogSettings		EnableLogTD
	__hyd_cfg_add_str		LogSettings		EnableLogHE
	__hyd_cfg_add_str		LogSettings		EnableLogPS
	__hyd_cfg_add_str		LogSettings		LogHEThreshold1
	__hyd_cfg_add_str		LogSettings		LogHEThreshold2

	__hyd_cfg_nl_append '[IEEE1905]'
	__hyd_cfg_add_str		IEEE1905Settings	StrictIEEE1905Mode
	__hyd_cfg_add_str		IEEE1905Settings	GenerateLLDP

	__hyd_cfg_nl_append '[HCP]'
	__hyd_cfg_add_str		HCPSettings		V1Compat

	__hyd_cfg_nl_append '[HCP]'
	__hyd_cfg_add_str		Wlan			WlanCheckFreqInterval

	__hyd_cfg_nl_append '[STEERMSG]'
	__hyd_cfg_add_str		SteerMsg		AvgUtilReqTimeout
	__hyd_cfg_add_str		SteerMsg		LoadBalancingCompleteTimeout
	__hyd_cfg_add_str		SteerMsg		RspTimeout

	# If the conifguration exists, go ahead and append it. Even if the Wi-Fi load
	# balancing feature is disabled, there should be no harm in doing so.

	if [ -f /etc/config/lbd ]; then
		local default_mode
		__hyd_get_default_mode default_mode
		config_get mode config 'Mode' $default_mode

		__hyd_cfg_nl_append '[WLB]'
		__hyd_cfg_add_str		config		DisableSteering

		if [ "${mode}" = 'HYCLIENT' ];then
			lbd_create_config $HYD_CONFIG_FILE 1 0 # running in multi-AP RE mode
		else
			lbd_create_config $HYD_CONFIG_FILE 1 1 # running in multi-AP CAP mode
		fi
	fi
}


__hyd_set_wlan_mcastenhance() {
	hyfi_get_wlan_ifaces $ieee1905managed_bridge wlan_ifaces
	[ -z "$wlan_ifaces" ] && return
	hyfi_strip_list $wlan_ifaces wlan_ifaces

	for wlan_iface in ${wlan_ifaces}; do
		iwpriv $wlan_iface mcastenhance $1
	done;
}

__hyd_reset_cpu_limit_value_for_legacy_boards() {
	config_load 'hyd'
	local tcp2g udp2g tcp5g udp5g limit name

	config_get tcp2g PathChWlan 'CPULimitedTCPThroughput_W2' '0'
	[ "$tcp2g" -gt 0 ] && return 1

	config_get udp2g PathChWlan 'CPULimitedUDPThroughput_W2' '0'
	[ "$udp2g" -gt 0 ] && return 1

	config_get tcp5g PathChWlan 'CPULimitedTCPThroughput_W5' '0'
	[ "$tcp5g" -gt 0 ] && return 1

	config_get udp5g PathChWlan 'CPULimitedUDPThroughput_W5' '0'
	[ "$udp5g" -gt 0 ] && return 1

	[ -f /tmp/sysinfo/board_name ] || return 1
	name=`cat /tmp/sysinfo/board_name`

	case "$name" in
	reh132 | aph126 | aph128 | db120)
		limit=160
		;;
	aph131)
		limit=300
		;;
	*)
		# Max u_int32.  If the throughput should be limited for a particular
		# board, add an entry for it above.
		limit=4294967295
		;;
	esac

	uci set hyd.PathChWlan.CPULimitedTCPThroughput_W2=$limit
	uci set hyd.PathChWlan.CPULimitedUDPThroughput_W2=$limit
	uci set hyd.PathChWlan.CPULimitedTCPThroughput_W5=$limit
	uci set hyd.PathChWlan.CPULimitedUDPThroughput_W5=$limit
	uci commit hyd
}

start() {
	hyfi_lock
	__stop_daemon

	config_load 'hyd'
	config_get_bool enabled config 'Enable' '0'
	local hyd_rcd_enabled=`ls /etc/rc.d/S${START}hyd 2> /dev/null`

	[ "$enabled" -gt 0 -a -n "$hyd_rcd_enabled" ] || {
		hyfi_unlock
		return 1
	}


	# Enable hyfi-netfilter
	if [ -f /proc/sys/net/bridge/bridge-nf-call-custom ]; then
		sysctl -w net.bridge.bridge-nf-call-custom=1
	fi

	# Get the IEEE1905.1 managed bridge name and attach
	hyfi_get_ieee1905_managed_iface ieee1905managed_bridge

	# Bail out from starting hyd if attach fails.
	if ! hyctl attach br$ieee1905managed_bridge; then
		stop
		hyfi_unlock
		return 1
	fi

	# Enable wlan Hy-Fi multicast enhancement
	__hyd_set_wlan_mcastenhance 5

	__hyd_reset_cpu_limit_value_for_legacy_boards

	hyfi_echo hyd "starting daemon"
	# Create configuration file and start hyd
	__hyd_create_config
	${SVCDBG}service_start ${SERVICE_PATH} -d -C "$HYD_CONFIG_FILE"

	touch $HYD_RUN_FILE
        # By default disable retag of DSCP when multicast enhancement is enabled. 
	hyctl setmc br$ieee1905managed_bridge retag disable
	hyfi_unlock
}

__stop_daemon() {
	# Disable the ECM classifier
	if [ -w "${ECM_SYSFS_FILE}" ]; then
		echo 0 > "${ECM_SYSFS_FILE}"
	fi

	${SVCDBG}service_stop ${SERVICE_PATH}

	# Workaround, sometimes service_stop does not kill hyd
	start-stop-daemon -K -x ${SERVICE_PATH} -s SIGKILL > /dev/null
}

__stop_hyfi_bridging() {
	config_load 'hyd'

	# Disable hyfi-netfilter
	if [ -f /proc/sys/net/bridge/bridge-nf-call-custom ]; then
		sysctl -w net.bridge.bridge-nf-call-custom=0
	fi

	# Get the IEEE1905.1 managed bridge name and detach
	hyfi_get_ieee1905_managed_iface ieee1905managed_bridge
	hyctl detach br$ieee1905managed_bridge
}

stop() {
	__stop_daemon
	__stop_hyfi_bridging

	# Disable wlan Hy-Fi multicast enhancement
	__hyd_set_wlan_mcastenhance 2
}

stop_wifidown() {
	__stop_daemon

	# Do not stop the bridging since the interfaces are still attached
	# to the bridge. If we stopped the bridging, this can cause a temporary
	# loop and may lead to incorrect WDS entries. By leaving the bridging
	# rules in place even though hyd is not running, we should be able to
	# prevent the loops prior to the point the Wi-Fi interfaces are destroyed.

	# No need to stop multicast enhancement when the interfaces are being
	# destroyed.
}

restart() {
	[ -f "$HYD_RUN_FILE" ] || return
	start
}
