#!/bin/sh

update_conf=wifi
while getopts ":t:" opt;do
    case $opt in
        t)
            if [ "${OPTARG}" = "all" ]; then
                update_conf="all"
            elif [ "${OPTARG}" = "wigig" ]; then
                update_conf="wigig"
            else
                update_conf="wifi"
            fi
            ;;
    esac
done

if [ "$update_conf" = "all" ]; then
    echo "" > /etc/config/wigig
    echo "" > /etc/config/wireless
elif [ "$update_conf" = "wigig" ]; then
    echo "" > /etc/config/wigig
else
    echo "" > /etc/config/wireless
fi
. /etc/dni-wifi-config

wifi_topology_file=${WIFI_TOPOLOGY_FILE:-/tmp/wifi_topology}
get_intf_onoff()
{
    parent_radio=`echo $2 | awk -F _ '{print $1}'`
    second_type=`echo $2 | awk -F _ '{print $NF}'`
    eval wl_parent_exist=\$`echo $parent_radio`_exist
    eval wl_config="\$FORCE_CREATE_$2_VAP"
    
    if [ "$wl_parent_exist" = "on" ] && [ "$wl_config" = "on" ]; then
        eval export -- "${1}=on"
    else
        if [ "$second_type" = "guest" ]; then
            eval export -- "${1}=off"
        else
            # if not guest, $2 should be the name of this VAP
            eval wl_op_type=\$`echo $2`_operation_type
            if [ -z "$wl_op_type" -o "$wl_op_type" = "none" ]; then
                eval export -- "${1}=off"
            else
                eval export -- "${1}=on"
            fi
        fi
    fi
}

# This function is to get the prefix of environment variables.
# If environment variables are all named according to same rule, then
# this function will provide help on getting environment variables.
get_wl_prefix()
{
    case "$1" in
        wlg)
            wl_prefix=wl
            ;;
        wla)
            wl_prefix=wla
                ;;
        wlg_guest)
            wl_prefix=wlg1
            ;;
        wla_guest)
            wl_prefix=wla1
            ;;
        wig)
            wl_prefix=wig
            ;;
        wlg_ap_bh|wlg_sta|wla_ap_bh|wla_sta)
            wl_prefix=$1
            ;;
        wla2*)
            wl_prefix=$(echo wla_2nd${1#wla2})
            ;;
    esac
}

wl_section=
get_wl_section()
{
    if [ "$1" != "wig" -a "$USE_QCA_SECTION_RULE" = "1" ]; then
        eval wl_section=\$`echo $1`_section
    else
        eval wl_section=$1
    fi

    [ -z "$wl_section" ] && wl_section=$1
}

assign_vap_option()
{
    eval wl_onoff=\$`echo $1`_if_onoff
    eval wl_create_vap=\$FORCE_CREATE_$1_VAP

    if [ "$wl_onoff" = "off" -a "$wl_create_vap" = "on" ] || [ "$wl_onoff" = "on" -a "$wl_hw_btn_state" = "off" ]; then
        uci set wireless.${wl_section}.vap_only=1
    fi
}

generate_mac()
{
    case "$1" in
        wlg)
            [ -f /tmp/mac_addr_2g ] && wl_value=`cat /tmp/mac_addr_2g`
            [ -n "$wl_value" -a "$wl_value" != "00:00:00:00:00:00" ] || {
                wl_value=$mac_2g
            }
            uci set wireless.${g_device}.macaddr=${wl_value:-"4C:60:DE:CE:61:AE"}
        ;;
        wla)
            [ -f /tmp/mac_addr_5g ] && wl_value=`cat /tmp/mac_addr_5g`
            [ -n "$wl_value" -a "$wl_value" != "00:00:00:00:00:00" ] || {
                wl_value=$mac_5g
            }
            uci set wireless.${a_device}.macaddr=${wl_value:-"4C:60:DE:CE:61:AF"}
        ;;
        wla2)
            [ -f /tmp/mac_addr_2nd5g ] && wl_value=`cat /tmp/mac_addr_2nd5g`
            [ -n "$wl_value" -a "$wl_value" != "00:00:00:00:00:00" ] || {
                wl_value=$mac_2nd_5g
            }
            uci set wireless.${a2_device}.macaddr=${wl_value:-"4C:60:DE:CE:61:B0"}
        ;;
    esac
}

generate_channel()
{
    eval wl_value=\$`echo $1`_channel

    if [ "$1" = "wlg" ]; then
        uci set wireless.${g_device}.channel=${wl_value}
    elif [ "$1" = "wla" ]; then
        uci set wireless.${a_device}.channel=${wl_value}
    elif [ "$1" = "wla2" ]; then
        uci set wireless.${a2_device}.channel=${wl_value}
    elif [ "$1" = "wig" ]; then
        uci set wigig.${wig_device}.channel=${wl_value:-2}
    fi
}

generate_hwmode()
{
    eval wl_value=\$`echo $1`_hwmode

    if [ "$1" = "wlg" ]; then
        uci set wireless.${g_device}.hwmode=${wl_value:-11g}
    elif [ "$1" = "wla" ]; then
        uci set wireless.${a_device}.hwmode=${wl_value:-11a}
    elif [ "$1" = "wla2" ]; then
        uci set wireless.${a2_device}.hwmode=${wl_value:-11a}
    elif [ "$1" = "wig" ]; then
        uci set wigig.${wig_device}.hwmode=${wl_value:-11ad}
    fi
}

generate_htmode()
{
    eval wl_value=\$`echo $1`_htmode

    if [ "$1" = "wlg" ]; then
        uci set wireless.${g_device}.htmode=${wl_value:-auto}
    elif [ "$1" = "wla2" ]; then
        uci set wireless.${a2_device}.htmode=${wl_value:-auto}
    else
        uci set wireless.${a_device}.htmode=${wl_value:-auto}
    fi
}

generate_keepalive()
{
    eval wl_value=\$`echo $1`_keepalive

    if [ "$1" = "wlg" ]; then
        uci set wireless.${g_device}.keepalive=${wl_value:-0}
    elif [ "$1" = "wla" ]; then
        uci set wireless.${a_device}.keepalive=${wl_value:-0}
    elif [ "$1" = "wla2" ]; then
        uci set wireless.${a2_device}.keepalive=${wl_value:-0}
    elif [ "$1" = "wig" ]; then
        uci set wigig.${wig_device}.keepalive=${wl_value:-0}
    fi
}

generate_sta_dfs()
{
    eval wl_value=\$`echo $1`_sta_dfs_en

    if [ -n "$wl_value" ]; then
        if [ "$1" = "wlg" ]; then
            uci set wireless.${g_device}.staDFSEn=${wl_value}
        elif [ "$1" = "wla" ]; then
            uci set wireless.${a_device}.staDFSEn=${wl_value}
        elif [ "$1" = "wla2" ]; then
            uci set wireless.${a2_device}.staDFSEn=${wl_value}
        elif [ "$1" = "wig" ]; then
            uci set wigig.${wig_device}.staDFSEn=${wl_value}
        fi
    fi
}

#
# Generate "wireless.<DEVICE>.disabled" in /etc/config/wireless or
# "wigig.<DEVICE>.disabled" in /etc/config/wigig
#
# Used variables in /etc/dni-wifi-config:
#     wlg_if_onoff  # 2.4 GHz
#     wla_if_onoff  # 5 GHz
#     wig_if_onoff  # 11ad
#
# $1: "wlg" when device is of 2.4 GHz
#     "wla" when device is of 5 GHz
#     "wig" when device is of 60 GHz
#
generate_disabled()
{
    local cfgfile
    local device
    local wl_value

    case "$1" in
        wlg)
            cfgfile=wireless
            device=$g_device
            ;;
        wla)
            cfgfile=wireless
            device=$a_device
            ;;
        wla2)
            cfgfile=wireless
            device=$a2_device
            ;;
        wig)
            cfgfile=wigig
            device=$wig_device
            ;;
        *)
            ;;
    esac

    eval wl_value=\$`echo $1`_if_onoff

    if [ "$wl_value" = "off" ]; then
        uci set ${cfgfile}.${device}.disabled=1
    fi
}

generate_cfreq2()
{
    eval wl_value=\$`echo $1`_cfreq2

    if [ "$1" = "wla" ]; then
        [ -n "$wl_value" ] && uci set wireless.${wl_section}.cfreq2=${wl_value}
    fi
}

generate_tpscale()
{
    eval wl_value=\$`echo $1`_tpscale

    case "$1" in
        wlg)
            uci set wireless.${g_device}.tpscale=${wl_value:-0}
        ;;
        wla)
            uci set wireless.${a_device}.tpscale=${wl_value:-0}
        ;;
        wla2)
            uci set wireless.${a2_device}.tpscale=${wl_value:-0}
        ;;
    esac

}

generate_wifi_hw_button_state()
{
    if [ "$wlg_exist" = "on" -a "$wla_exist" = "on" ]; then
        hw_btn_state=$wl_hw_btn_state
    else
        if [ "$1" = "$g_device" ]; then
            hw_btn_state=$wlg_if_onoff
        else
            hw_btn_state=$wla_if_onoff
        fi
    fi

    if [ "$wl_cb_if_onoff" = "on" ]; then
        hw_btn_state="on"
    fi

    uci set wireless.${1}.hw_btn_state=${hw_btn_state}
}

generate_mode()
{
#    eval wl_wds_onoff=\$`echo $1`_wds_onoff
#    eval wl_wds_role=\$`echo $1`_wds_role
#    if [ "$wl_wds_onoff" = "on" -a "$wl_wds_role" = "repeater" ]; then
#        cat <<EOF >> $wifi_config
#        option mode     wds
#EOF
#    else
#        cat <<EOF >> $wifi_config
#        option mode     ap
#EOF
#    fi

    eval operation_type=\$`echo $1`_operation_type
    [ -z "$operation_type" ] && operation_type="normal_ap"
    if [ "$1" = "wig" ]; then
        # TODO: support station mode
        uci set wigig.${wl_section}.mode=ap
        return
    fi
    if [ "$wl_cb_if_onoff" = "on" -o "$operation_type" = "ex_sta" ]; then
        uci set wireless.${wl_section}.mode=sta
        uci set wireless.${wl_section}.cb=dni
        uci set wireless.${wl_section}.athnewind=1
        uci set wireless.${wl_section}.vap_ind=0
    elif [ "$operation_type" = "backhaul_sta" ]; then
        uci set wireless.${wl_section}.mode=sta
        uci set wireless.${wl_section}.wds=1
        uci set wireless.${wl_section}.athnewind=1
        uci set wireless.${wl_section}.vap_ind=0
        uci set wireless.${wl_section}.backhaul=1
        uci set wireless.${wl_section}.wsplcd_unmanaged=1
        uci set wireless.${wl_section}.repacd_security_unmanaged=1
    elif [ "$operation_type" = "backhaul_ap" ]; then
        uci set wireless.${wl_section}.mode=ap
        uci set wireless.${wl_section}.athnewind=1
        uci set wireless.${wl_section}.vap_ind=0
        if [ "$1" != "wla2_ap_bh" -o "x$wla2_ap_bh_backhaul" = "x1" ]; then
            uci set wireless.${wl_section}.wds=1
            uci set wireless.${wl_section}.backhaul=1
            uci set wireless.${wl_section}.wsplcd_unmanaged=1
            uci set wireless.${wl_section}.repacd_security_unmanaged=1
        fi
    else
        uci set wireless.${wl_section}.mode=ap
        local radio=`echo $1 | awk -F_ '{print $1}'`
        eval sta_operation_type=\$`echo $radio`_sta_operation_type
        if [ "x$sta_operation_type" != "xnone" ]; then
            uci set wireless.${wl_section}.athnewind=1
        fi
        case "$1" in
            wlg_guest | wla_guest)
                uci set wireless.${wl_section}.wsplcd_unmanaged=1
            ;;
        esac
    fi
}

generate_vhtng()
{
    #
    # Enable "wireless.<IFACE>.vht_11ng" only when 2.4 GHz device is set to
    # either HT20 or HT40.
    #
    # This can be simply implemented by checking whether "wlg_htmode" is empty
    # or not because, according to /etc/dni-wifi-config , "wlg_htmode"
    # contains value only when "wlg_hwmode" is "11ng".
    #
    if [ "$vht_11ng" = "on" -a "x$wlg_htmode" != "x" ]; then
        uci set wireless.${wl_section}.vht_11ng=1
    fi
}

generate_wps()
{
    eval wps_onoff=\$`echo $1`_wps_onoff

    if [ "$wps_onoff" = "off" ]; then
        return;
    fi
    
    if [ "$wsc_lock_down" = "1" ]; then
        wl_wps_ap_setup_locked=1
    else
        eval wl_wps_ap_setup_locked=\$`echo $1`_wps_ap_setup_locked
    fi

    eval wl_wps_configured=\$`echo $1`_wps_configured
    if [ "$wl_wps_configured" = "configured" ]; then
        wl_wps_enable_onoff=2
    else
        wl_wps_enable_onoff=1
    fi

    wl_value=$wps_config_method
    [ -n "$wl_value" ] || {
        #default config method
        wl_value="virtual_push_button physical_push_button"
    }

    if [ "$1" = "wlg" -o "$1" = "wla" ]; then
        eval operation_type=\$`echo $1`_ap_operation_type
    else
        eval operation_type=\$`echo $1`_operation_type
    fi

    if [ "$operation_type" = "normal_ap" -o "$operation_type" = "backhaul_ap" ]; then
        uci set wireless.${wl_section}.ap_setup_locked=${wl_wps_ap_setup_locked}
        uci set wireless.${wl_section}.wps_state=${wl_wps_enable_onoff}
    fi
    uci set wireless.${wl_section}.wps_config="$wl_value"
    uci set wireless.${wl_section}.wps_pbc=1
}

generate_wps_device_name()
{
    eval wps_onoff=\$`echo $1`_wps_onoff
    
    if [ "$wps_onoff" = "off" ]; then
        return;
    fi

    wl_device_name="`echo $wps_device_name`(Wireless AP)"

    uci set wireless.${wl_section}.wps_device_name="${wl_device_name}"
}

generate_ssid()
{
    eval wl_value=\$`echo $1`_ssid

    # handle special characters
    wl_value=$(echo "$wl_value" | sed  -e 's/\\"/\"/g')
    wl_value=$(echo "$wl_value" | sed  -e 's/\\\\\\\\/\\/g')
    wl_value=$(echo "$wl_value" | sed  -e 's/\\\\\\`/\`/g')

    if [ "$1" = "wig" ]; then
        uci set wigig.${wl_section}.ssid="${wl_value:-DNIWIFI}"
    else
        uci set wireless.${wl_section}.ssid="${wl_value:-DNIWIFI}"
    fi
}

generate_hide_ssid()
{
    eval wl_value=\$`echo $1`_hide_ssid_onoff

    if [ "$1" = "wig" ]; then
        cfgfile=wigig
    else
        cfgfile=wireless
    fi

    if [ "$wl_value" = "on" ]; then
        uci set ${cfgfile}.${wl_section}.hidden=1
    else
        uci set ${cfgfile}.${wl_section}.hidden=0
    fi
}

generate_puren()
{
    eval wl_value=\$`echo $1`_puren_onoff
    if [ "$wl_value" = "on" ]; then
        uci set wireless.${wl_section}.puren=1
    fi
}

generate_doth()
{
    eval wl_value=\$`echo $1`_doth
    uci set wireless.${wl_section}.doth=${wl_value:-0}
}

generate_disablecoext()
{
    eval wl_value=\$`echo $1`_disablecoext
    uci set wireless.${wl_section}.disablecoext=${wl_value:-0}
}

generate_rrm()
{
    eval wl_value=\$`echo $1`_rrm
    uci set wireless.${wl_section}.rrm=${wl_value:-0}
}

generate_security()
{
    eval wl_sectype=\$`echo $1`_sectype

    if [ "$1" = "wig" ]; then
        cfgfile=wigig
    else
        cfgfile=wireless
    fi

    case "$wl_sectype" in
        off)
            eval uci set ${cfgfile}.${wl_section}.encryption=none
            ;;
        *wep*)
            get_wl_prefix "$1"
            load_wep_config "$wl_prefix" "$1"
            eval wl_wep_auth_type=\$wep_auth_type_`echo $((${1}_auth))`
            case "$wl_wep_auth_type" in
                open)
                    auth_type="open"
                    ;;
                shared)
                    auth_type="shared"
                    ;;
                *)
                    auth_type="mixed"
                    ;;
            esac
            eval wl_wep_keyix=\$`echo $1`_key
            eval wl_key_length=\$`echo $1`_key_length
            uci set wireless.${wl_section}.encryption=${wl_sectype}-${auth_type}
            uci set wireless.${wl_section}.key=${wl_wep_keyix}
            for idx in 1 2 3 4; do
                eval wl_wep_key=\$`echo $1`_key${idx}
                [ -n "$wl_wep_key" ] && {
                    tmp_key_length=`expr length $wl_wep_key`
                    if [ "$wl_key_length" = "5" ]; then
                        if [ "$tmp_key_length" = "10" ]; then
                            uci set wireless.${wl_section}.key${idx}_format=HEX
                        elif [ "$tmp_key_length" = "5" ]; then
                            uci set wireless.${wl_section}.key${idx}_format=ASCII
                        fi
                    else
                        if [ "$tmp_key_length" = "26" ]; then
                            uci set wireless.${wl_section}.key${idx}_format=HEX
                        elif [ "$tmp_key_length" = "13" ]; then
                            uci set wireless.${wl_section}.key${idx}_format=ASCII
                        fi
                    fi
                }
                uci set wireless.${wl_section}.key${idx}=${wl_wep_key}
            done
            ;;
        *psk*)
            get_wl_prefix "$1"
            dni_config_get_psk_phrase wl_psk_phrase wl_encryption "$wl_prefix" "$wl_sectype"
            if [ "$1" = "wig" ]; then
                uci set wigig.${wl_section}.encryption="${wl_sectype}+gcmp"
            else
                uci set wireless.${wl_section}.encryption=${wl_encryption}
            fi

            # handle special characters
            wl_psk_phrase=$(echo "$wl_psk_phrase" | sed  -e 's/\\"/\"/g')
            wl_psk_phrase=$(echo "$wl_psk_phrase" | sed  -e 's/\\\\/\\/g')
            wl_psk_phrase=$(echo "$wl_psk_phrase" | sed  -e 's/\\`/\`/g')

            uci set ${cfgfile}.${wl_section}.key="$wl_psk_phrase"
            ;;
        *wpa*)
            get_wl_prefix "$1"
            load_wpa_config "$wl_prefix"
            uci set wireless.${wl_section}.encryption=${_tmp_wpa}
            uci set wireless.${wl_section}.key=${wl_auth_sv_secret}
            uci set wireless.${wl_section}.server=${wl_auth_sv_ip}
            uci set wireless.${wl_section}.port=${wl_auth_sv_port}
            ;;
    esac
            
}

generate_protocol_setting()
{
    parent_radio=`echo $1 | awk -F _ '{print $1}'`
    eval wl_rts_value=\$`echo $parent_radio`_rts
    eval wl_frag_value=\$`echo $parent_radio`_frag
    eval wl_wmm_value=\$`echo $parent_radio`_wmm_onoff
    eval wl_preamble_value=\$`echo $parent_radio`_preamble
    eval wl_country_ie_value=\$`echo $parent_radio`_country_ie_onoff

    if [ -n "$wl_rts_value" ]; then
        uci set wireless.${wl_section}.rts=${wl_rts_value}
    fi

    if [ -n "$wl_frag_value" ]; then
        uci set wireless.${wl_section}.frag=${wl_frag_value}
    fi

    if [ -n "$wl_wmm_value" ]; then
        if [ "$wl_wmm_value" = "on" ]; then
            uci set wireless.${wl_section}.wmm=1
        else
            uci set wireless.${wl_section}.wmm=0
        fi
    fi

    if [ -n "$wl_country_ie_value" ]; then
        if [ "$wl_country_ie_value" = "on" ]; then
            uci set wireless.${wl_section}.countryie=1
        else
            uci set wireless.${wl_section}.countryie=0
        fi
    fi

    if [ -n "$wl_preamble_value" ]; then
        case "$wl_preamble_value" in
            *long*)
                uci set wireless.${wl_section}.short_preamble=0
                ;;
            *)
                uci set wireless.${wl_section}.short_preamble=1
                ;;
        esac
    fi
}

generate_acl()
{
    parent_radio=`echo $1 | awk -F _ '{print $1}'`

    eval wl_acl_onoff=\$`echo $parent_radio`_acl_onoff
    if [ "$wl_acl_onoff" = "off" ]; then
        return;
    fi

    uci set wireless.${wl_section}.macfilter=allow
    dni_config_get acl_sta_num wl_acl_num
    acl_sta_num=${acl_sta_num:-0}
    num=1
    while [ $num -le $acl_sta_num ]; do
        dni_config_get mac "wlacl${num}"
        addr=$(echo "$mac" | while read name value; do echo "$value"; done)
        uci add_list wireless.${wl_section}.maclist=${addr}
        num=$(($num + 1))
    done
}

generate_wds()
{
    eval wl_wds_onoff=\$`echo $1`_wds_onoff
    if [ "$wl_wds_onoff" = "off" ]; then
        return
    fi

    eval wl_wds_role=\$`echo $1`_wds_role

    # The variable naming of wds is different with others.
    # Use another way for it.
    case "$1" in
        wlg)
            wl_wds_postfix=
            radio_device="${g_device}"
            ;;
        wla)
            wl_wds_postfix="_a"
            radio_device="${a_device}"
            ;;
    esac

    # ROOTAP (Base station) section
    if [ "$wl_wds_role" = "rootap" ]; then
        for idx in 1 2 3 4; do
            dni_config_get wl_repeater_mac repeater_mac${idx}${wl_wds_postfix}
            if [ "x$wl_repeater_mac" != "x" ]; then
                uci add_list wireless.${wl_section}.maclist=${wl_repeater_mac}
                uci add_list wireless.${wl_section}.nawds_add_repeater=${wl_repeater_mac}
            fi
        done

        dni_config_get wds_client_assoc_onoff wds_endis_mac_client${wl_wds_postfix}
        if [ "$wds_client_assoc_onoff" = "off" ]; then
            uci set wireless.${wl_section}.macfilter=allow
        fi
        uci set wireless.${wl_section}.mode=ap
        uci set wireless.${wl_section}.wds=1
        uci set wireless.${wl_section}.nawds_mode=1
    fi

    if [ "$wl_wds_role" = "repeater" ]; then
        eval wl_wds_repeater_assoc_onoff=\$`echo $1`_wds_repeater_assoc_onoff
        dni_config_get wl_wds_rootap_mac basic_station_mac${wl_wds_postfix}

        # Does not allow wireless client association.
        if [ "$wl_wds_repeater_assoc_onoff" = "off" ]; then
            uci set wireless.${wl_section}.mode=sta
            uci set wireless.${wl_section}.wds=1
            uci set wireless.${wl_section}.bssid=${wl_wds_rootap_mac}
            # sta mode doesn't need set ssid
            uci delete wireless.${wl_section}.ssid
        else
            # allow wireless client association, so there will be two
            # interfaces created.

            # set wds ap vap
            uci set wireless.${wl_section}.mode=ap
            uci set wireless.${wl_section}.wds=1
            uci set wireless.${wl_section}.vap_ind=1

            # set wds sta vap
            uci set wireless."${1}_wds_sta"=wifi-iface
            uci set wireless."${1}_wds_sta".network=${lan_ifname#"br"}
            uci set wireless."${1}_wds_sta".device=${radio_device}
            uci set wireless."${1}_wds_sta".bridge=${lan_ifname}
            uci set wireless."${1}_wds_sta".mode=sta
            uci set wireless."${1}_wds_sta".wds=1
            uci set wireless."${1}_wds_sta".bssid=${wl_wds_rootap_mac}
            uci set wireless."${1}_wds_sta".vap_ind=1
        fi
    fi

}

generate_bintval()
{
    case "$1" in
        wlg)
            uci set wireless.${wl_section}.bintval=100
            ;;
        wla)
            uci set wireless.${wl_section}.bintval=100
            ;;
        wlg_guest)
            uci set wireless.${wl_section}.bintval=200
            ;;
        wla_guest)
            uci set wireless.${wl_section}.bintval=200
            ;;
    esac
}

generate_dtim()
{
    case "$1" in
        wlg | wla)
            eval guest_if_onoff=\$`echo $1`_guest_if_onoff
            # guest network is disabled
            if [ "$guest_if_onoff" = "off" ]; then
                uci set wireless.${wl_section}.dtim_period=${wl_dtim_wo_guest}
            else
                uci set wireless.${wl_section}.dtim_period=${wl_dtim_w_guest}
            fi
            ;;
        wlg_guest | wla_guest)
            uci set wireless.${wl_section}.dtim_period=${wl_guest_dtim}
            ;;
    esac
}

generate_PIN()
{
    [ -f /sbin/fetchPIN ] && /sbin/fetchPIN

    if [ -f /tmp/wpspin-setted ]; then
        pin_num=`cat /tmp/wpspin-setted`
    else
        pin_num=`cat /tmp/wpspin`
    fi
    uci set wireless.${wl_section}.wps_pin=${pin_num-:12345670}
}

generate_lan_restricted_access()
{
    eval wl_lan_restricted_access_onoff=\$`echo $1`_lan_restricted_access_onoff
    # if lan restricted access is off, it means every one can access the network, so
    # we don't need to generate ebtables rules.
    if [ "$wl_lan_restricted_access_onoff" = "off" ]; then
        return;
    fi

    wl_guest_iptv_on=`config get wan_brig_guest_ssid1`
    wla_guest_iptv_on=`config get wan_brig_guest_ssid2`
    if [ "$1" = "wlg_guest" -a "${wl_guest_iptv_on}" = "1" ] || [ "$1" = "wla_guest" -a "${wla_guest_iptv_on}" = "1" ]; then
        gui_region=`config get GUI_Region`
        [ -f /tmp/firmware_region ] && firmware_region=`cat /tmp/firmware_region | awk '{print $1}'`
        if [ "$firmware_region" = "" ] || [ "$firmware_region" = "WW" ]; then
            if [ "$gui_region" = "Russian" ] || [ "$gui_region" = "Chinese" ]; then
                return;
            fi
        elif [ "$firmware_region" = "RU" ] || [ "$firmware_region" = "PR" ]; then
                return;
        fi
    fi

    uci set wireless.${wl_section}.lan_restricted=1
    uci set wireless.${wl_section}.lan_ipaddr=${lan_ipaddr}
}

generate_wireless_isolation()
{
    eval wl_wireless_isolation_onoff=\$`echo $1`_wireless_isolation_onoff
    if [ "$wl_wireless_isolation_onoff" = "off" ]; then
        return;
    fi

    uci set wireless.${wl_section}.isolate=1
}

generate_bf()
{
    local wl_value=

    eval wl_bf_onoff=\$`echo $1`_bf_onoff
    if [ "$wl_bf_onoff" = "on" ]; then
        wl_value=1
    elif [ "$wl_bf_onoff" = "off" ]; then
        wl_value=0
    fi
    case "$1" in
        wlg)
            uci set wireless.${g_device}.bf=${wl_value:-0}
            ;;
        wla)
            uci set wireless.${a_device}.bf=${wl_value:-0}
            ;;
        wla2)
            uci set wireless.${a2_device}.bf=${wl_value:-0}
            ;;
    esac
}

#
# Generate "wireless.<DEVICE>.implicitbf" in /etc/config/wireless
#
# Used variable in etc/dni-wifi-config: wla_implicit_bf_onoff
#
# $1: "wla" when device is 5 GHz
#
generate_implicitbf()
{
    eval wl_implicit_bf_onoff=\$`echo $1`_implicit_bf_onoff

    if [ "$wl_implicit_bf_onoff" = "on" ]; then
        wl_value=1
    else
        wl_value=0
    fi

    case "$1" in
        wlg)
            uci set wireless.${g_device}.implicitbf=${wl_value:-0}
        ;;
        wla)
            uci set wireless.${a_device}.implicitbf=${wl_value:-0}
        ;;
        wla2)
            uci set wireless.${a2_device}.implicitbf=${wl_value:-0}
        ;;
    esac
}

#
# Generate "wireless.<DEVICE>.mu_mimo" in /etc/config/wireless
#
# Used variable in etc/dni-wifi-config: wla_mu_mimo_onoff
#
# $1: "wla" when device is 5 GHz
#
generate_mu_mimo()
{
    local wl_mu_mimo_value=

    eval wl_mu_mimo_onoff=\$`echo $1`_mu_mimo_onoff

    if [ "$wl_mu_mimo_onoff" = "on" ]; then
        wl_mu_mimo_value=1
    elif [ "$wl_mu_mimo_onoff" = "off" ]; then
        wl_mu_mimo_value=0
    fi

    case "$1" in
        wlg)
            uci set wireless.${g_device}.mu_mimo=${wl_mu_mimo_value:-0}
        ;;
        wla)
            uci set wireless.${a_device}.mu_mimo=${wl_mu_mimo_value:-0}
        ;;
        wla2)
            uci set wireless.${a2_device}.mu_mimo=${wl_mu_mimo_value:-0}
        ;;
    esac
}

generate_hostapd_debug_level()
{
    wl_hostapd_debug_level=$hostapd_debug_level

    if [ "$1" = "wig" ]; then
        cfgfile=wigig
    else
        cfgfile=wireless
    fi
    uci set ${cfgfile}.${wl_section}.hostapd_debug_level=${wl_hostapd_debug_level:-0}
}

generate_wifi_topology_file()
{
    if [ "$1" = "wlg" -o "$1" = "wla" ]; then
        eval operation_type=\$`echo $1`_ap_operation_type
    else
        eval operation_type=\$`echo $1`_operation_type
    fi
    case "$operation_type" in
        normal_ap)
            if_type="NORMAL"
            if_mode="AP"
            ;;
        ext_sta)
            if_type="EXT"
            if_mode="STA"
            ;;
        backhaul_ap)
            if_type="BACKHAUL"
            if_mode="AP"
            ;;
        backhaul_sta)
            if_type="BACKHAUL"
            if_mode="STA"
            ;;
        *)
            if_type="GUEST"
            if_mode="AP"
            ;;
    esac
    parent_radio=`echo $1 | awk -F _ '{print $1}'`
    case "$parent_radio" in
        wlg) wifi_device=$g_device ;;
        wla) wifi_device=$a_device ;;
        wla2) wifi_device=$a2_device ;;
    esac
    get_wl_prefix "$1"
    echo "$if_type:$if_mode:$wifi_device:$wl_ifname:${wl_section}:$wl_prefix" >> $wifi_topology_file
}

generate_ifname()
{
    eval wl_ifname=\$${1}_ifname

    cfgfile=wireless
    [ -n "$wl_ifname" ] && {
        uci set ${cfgfile}.${wl_section}.ifname=${wl_ifname}
        generate_wifi_topology_file $1
    }
}

generate_cca_threshold()
{
    eval wl_cca_threshold=\$${1}_cca_threshold

    if [ "$wl_cca_threshold" -lt -10 -a "$wl_cca_threshold" -gt -95 ]; then
        if [ "$1" = "wlg" ]; then
            uci set wireless.${g_device}.cca_threshold=${wl_cca_threshold}
        elif [ "$1" = "wla" ]; then
            uci set wireless.${a_device}.cca_threshold=${wl_cca_threshold}
        elif [ "$1" = "wla2" ]; then
            uci set wireless.${a2_device}.cca_threshold=${wl_cca_threshold}
        elif [ "$1" = "wig" ]; then
            uci set wigig.${wig_device}.cca_threshold=${wl_cca_threshold}
        fi
    fi
}

generate_dyn_bw_rts()
{
    eval wl_value=\$`echo $1`_dyn_bw_rts
    uci set wireless.${wl_section}.dyn_bw_rts=${wl_value:-0}
}

generate_rps()
{
    eval wl_value=\$`echo $1`_rps
    if [ -n "$wl_value" ]; then
        uci set wireless.${wl_section}.rps=${wl_value}
    fi
}

create_new_iface()
{
    [ "$USE_QCA_SECTION_RULE" = "1" ] && {
        uci add wireless wifi-iface > /dev/null
    } || {
        uci set wireless.${wl_section}=wifi-iface
    }
}

if [ "$update_conf" = "wifi" -o "$update_conf" = "all" ]; then
    rm -rf $wifi_topology_file
    # config driver parameters
    uci set wireless.qcawifi=qcawifi
    [ "$wlg_super_wifi" != "0" ] && uci set wireless.qcawifi.wl_super_wifi=${wlg_super_wifi}
    [ "$wla_super_wifi" != "0" ] && uci set wireless.qcawifi.wla_super_wifi=${wla_super_wifi}

    if [ "$wlg_ap_operation_type" != "none" -o "$wlg_sta_operation_type" != "none" -o "$wlg_ap_bh_operation_type" != "none" ]; then
        uci set wireless.${g_device}=wifi-device
        uci set wireless.${g_device}.type=qcawifi
        uci set wireless.${g_device}.country=${country_code}
        uci set wireless.${g_device}.ODM=dni
        uci set wireless.${g_device}.sys_bridge=${lan_ifname}
        uci set wireless.${g_device}.repacd_auto_create_vaps=0
        uci set wireless.${g_device}.dbdc_enable=${DBDC_ENABLE:-0}
        uci set wireless.${g_device}.nf_baseline=-102
        if [ "$wlg_ap_operation_type" != "none" -o "$wlg_ap_bh_operation_type" != "none" ]; then
            uci set wireless.${g_device}.obss_rssi_th=${wlg_obss_rssi_th}
            uci set wireless.${g_device}.obss_rx_rssi_th=${wlg_obss_rx_rssi_th}
        fi
        generate_wifi_hw_button_state "$g_device"
        generate_mac "wlg"
        generate_channel "wlg"
        generate_hwmode "wlg"
        generate_htmode "wlg"
        generate_tpscale "wlg"
        generate_bf "wlg"
        generate_implicitbf "wlg"
        generate_mu_mimo "wlg"
        generate_keepalive "wlg"
        generate_cca_threshold "wlg"
        generate_sta_dfs "wlg"
    fi

    if [ "$wla_exist" = "on" ] &&
           [ "$wla_ap_operation_type" != "none" -o "$wla_sta_operation_type" != "none" -o "$wla_ap_bh_operation_type" != "none" ]; then
        uci set wireless.${a_device}=wifi-device
        uci set wireless.${a_device}.type=qcawifi
        uci set wireless.${a_device}.country=${country_code}
        uci set wireless.${a_device}.ODM=dni
        uci set wireless.${a_device}.sys_bridge=${lan_ifname}
        uci set wireless.${a_device}.repacd_auto_create_vaps=0
        uci set wireless.${a_device}.dbdc_enable=${DBDC_ENABLE:-0}
        uci set wireless.${a_device}.nf_baseline=-104
        generate_wifi_hw_button_state "$a_device"
        generate_mac "wla"
        generate_channel "wla"
        generate_hwmode "wla"
        generate_htmode "wla"
        generate_tpscale "wla"
        generate_bf "wla"
        generate_implicitbf "wla"
        generate_mu_mimo "wla"
        generate_keepalive "wla"
        generate_cca_threshold "wla"
        generate_sta_dfs "wla"
    fi

    if [ "$wla2_exist" = "on" ] &&
           [ "$wla2_ap_operation_type" != "none" -o "$wla2_sta_operation_type" != "none" -o "$wla2_ap_bh_operation_type" != "none" ]; then
        uci set wireless.${a2_device}=wifi-device
        uci set wireless.${a2_device}.type=qcawifi
        uci set wireless.${a2_device}.country=${country_code}
        uci set wireless.${a2_device}.ODM=dni
        uci set wireless.${a2_device}.sys_bridge=${lan_ifname}
        uci set wireless.${a2_device}.repacd_auto_create_vaps=0
        uci set wireless.${a2_device}.dbdc_enable=${DBDC_ENABLE:-0}
        uci set wireless.${a2_device}.nf_baseline=-104
        generate_mac "wla2"
        generate_channel "wla2"
        generate_hwmode "wla2"
        generate_htmode "wla2"
        generate_tpscale "wla2"
        generate_bf "wla2"
        generate_implicitbf "wla2"
        generate_mu_mimo "wla2"
        generate_keepalive "wla2"
        generate_cca_threshold "wla2"
        generate_sta_dfs "wla2"
    fi

    get_intf_onoff _tmp_wlg_onoff "wlg"
    if [ "$_tmp_wlg_onoff" = "on" -a "$wlg_ap_operation_type" = "normal_ap" ]; then
        wl_vap="wlg"
        get_wl_section $wl_vap
        create_new_iface
        uci set wireless.${wl_section}.device=${g_device}
        uci set wireless.${wl_section}.network=${wlg_bridge#"br"}
        uci set wireless.${wl_section}.bridge=${wlg_bridge}
        uci set wireless.${wl_section}.vlan_pri=${wlg_priority}
        assign_vap_option $wl_vap
        generate_mode $wl_vap
        generate_vhtng $wl_vap
        generate_wps $wl_vap
        generate_wps_device_name $wl_vap
        generate_ssid $wl_vap
        generate_hide_ssid $wl_vap
        generate_puren $wl_vap
        generate_doth $wl_vap
        generate_disablecoext $wl_vap
        generate_rrm $wl_vap
        generate_security $wl_vap
        generate_protocol_setting $wl_vap
        generate_acl $wl_vap
        generate_wds $wl_vap
        generate_bintval $wl_vap
        generate_dtim $wl_vap
        generate_PIN $wl_vap
        generate_hostapd_debug_level $wl_vap
        generate_dyn_bw_rts $wl_vap
        generate_rps $wl_vap
        generate_ifname $wl_vap
        uci set wireless.${wl_section}.acsmindwell=500
    fi

    if [ "$wlg_ap_bh_operation_type" != "none" ]; then
        wl_vap="wlg_ap_bh"
        get_wl_section $wl_vap
        create_new_iface
        uci set wireless.${wl_section}.device=${g_device}
        uci set wireless.${wl_section}.network=${wlg_bridge#"br"}
        uci set wireless.${wl_section}.bridge=${wlg_bridge}
        # assign_vap_option "$wl_vap"
        generate_mode $wl_vap
        generate_ssid $wl_vap
        generate_security $wl_vap
        generate_vhtng $wl_vap
        generate_wps $wl_vap
        generate_hide_ssid $wl_vap
        generate_disablecoext $wl_vap
        # generate_protocol_setting $wl_vap
        generate_bintval $wl_vap
        # generate_PIN $wl_vap
        generate_ifname $wl_vap
        generate_hostapd_debug_level $wl_vap
        generate_dyn_bw_rts $wl_vap
        generate_rps $wl_vap
    fi

    if [ "$wlg_sta_operation_type" != "none" ]; then
        wl_vap="wlg_sta"
        get_wl_section $wl_vap
        create_new_iface
        uci set wireless.${wl_section}.device=${g_device}
        uci set wireless.${wl_section}.network=${wlg_bridge#"br"}
        uci set wireless.${wl_section}.bridge=${wlg_bridge}
        generate_mode $wl_vap
        generate_ssid $wl_vap
        generate_security $wl_vap
        generate_ifname $wl_vap
        generate_wps $wl_vap
        generate_hostapd_debug_level $wl_vap
        generate_protocol_setting $wl_vap
        generate_dyn_bw_rts $wl_vap
        generate_rps $wl_vap
    fi

    get_intf_onoff _tmp_wla_onoff "wla"
    if [ "$_tmp_wla_onoff" = "on" -a "$wla_ap_operation_type" = "normal_ap" ]; then
        wl_vap="wla"
        get_wl_section $wl_vap
        create_new_iface
        uci set wireless.${wl_section}.device=${a_device}
        uci set wireless.${wl_section}.network=${wla_bridge#"br"}
        uci set wireless.${wl_section}.bridge=${wla_bridge}
        uci set wireless.${wl_section}.vlan_pri=${wla_priority}
        assign_vap_option $wl_vap
        generate_cfreq2 $wl_vap
        generate_mode $wl_vap
        generate_wps $wl_vap
        generate_wps_device_name $wl_vap
        generate_ssid $wl_vap
        generate_hide_ssid $wl_vap
        generate_puren $wl_vap
        generate_doth $wl_vap
        generate_disablecoext $wl_vap
        generate_rrm $wl_vap
        generate_security $wl_vap
        generate_protocol_setting $wl_vap
        generate_acl $wl_vap
        generate_wds $wl_vap
        generate_bintval $wl_vap
        generate_dtim $wl_vap
        generate_PIN $wl_vap
        generate_hostapd_debug_level $wl_vap
        generate_ifname $wl_vap
        generate_dyn_bw_rts $wl_vap
        generate_rps $wl_vap
    fi

    if [ "$wla_ap_bh_operation_type" != "none" ]; then
        wl_vap="wla_ap_bh"
        get_wl_section $wl_vap
        create_new_iface
        uci set wireless.${wl_section}.device=${a_device}
        uci set wireless.${wl_section}.network=${wla_bridge#"br"}
        uci set wireless.${wl_section}.bridge=${wla_bridge}
        # assign_vap_option "$wl_vap"
        generate_mode $wl_vap
        generate_ssid $wl_vap
        generate_security $wl_vap
        generate_wps $wl_vap
        generate_hide_ssid $wl_vap
        generate_disablecoext $wl_vap
        generate_protocol_setting $wl_vap
        generate_bintval $wl_vap
        # generate_PIN $wl_vap
        generate_ifname $wl_vap
        generate_dyn_bw_rts $wl_vap
        generate_rps $wl_vap
        generate_hostapd_debug_level $wl_vap
        generate_wps $wl_vap
    fi

    if [ "$wla_sta_operation_type" != "none" ]; then
        wl_vap="wla_sta"
        get_wl_section $wl_vap
        create_new_iface
        uci set wireless.${wl_section}.device=${a_device}
        uci set wireless.${wl_section}.network=${wla_bridge#"br"}
        uci set wireless.${wl_section}.bridge=${wla_bridge}
        generate_mode $wl_vap
        generate_ssid $wl_vap
        generate_security $wl_vap
        generate_ifname $wl_vap
        generate_wps $wl_vap
        generate_dyn_bw_rts $wl_vap
        generate_rps $wl_vap
        generate_hostapd_debug_level $wl_vap
        generate_wps $wl_vap
    fi

    get_intf_onoff _tmp_wlg_guest_onoff "wlg_guest"
    if [ "$_tmp_wlg_guest_onoff" = "on" ]; then
        local local_network=${wlg_guest_bridge:-${lan_ifname}}
        local_network=${local_network#"br"}
        wl_vap="wlg_guest"
        get_wl_section $wl_vap
        create_new_iface
        uci set wireless.${wl_section}.device=${g_device}
        uci set wireless.${wl_section}.network=${local_network}
        uci set wireless.${wl_section}.bridge=${wlg_guest_bridge}
        uci set wireless.${wl_section}.vlan_pri=${wlg_guest_priority}
        assign_vap_option $wl_vap
        generate_mode $wl_vap
        generate_ssid $wl_vap
        generate_security $wl_vap
        generate_vhtng $wl_vap
        generate_hide_ssid $wl_vap
        generate_protocol_setting $wl_vap
        generate_acl $wl_vap
        generate_lan_restricted_access $wl_vap
        generate_wireless_isolation $wl_vap
        generate_bintval $wl_vap
        generate_dtim $wl_vap
        generate_doth $wl_vap
        generate_ifname $wl_vap
        generate_rrm $wl_vap
        generate_hostapd_debug_level $wl_vap
        generate_dyn_bw_rts $wl_vap
        generate_rps $wl_vap
    fi

    get_intf_onoff _tmp_wla_guest_onoff "wla_guest"
    if [ "$_tmp_wla_guest_onoff" = "on" ]; then
        local local_network=${wla_guest_bridge:-${lan_ifname}}
        local_network=${local_network#"br"}
        wl_vap="wla_guest"
        get_wl_section $wl_vap
        create_new_iface
        uci set wireless.${wl_section}.device=${a_device}
        uci set wireless.${wl_section}.network=${local_network}
        uci set wireless.${wl_section}.bridge=${wla_guest_bridge}
        uci set wireless.${wl_section}.vlan_pri=${wla_guest_priority}
        assign_vap_option $wl_vap
        generate_mode $wl_vap
        generate_ssid $wl_vap
        generate_security $wl_vap
        generate_hide_ssid $wl_vap
        generate_protocol_setting $wl_vap
        generate_acl $wl_vap
        generate_lan_restricted_access $wl_vap
        generate_wireless_isolation $wl_vap
        generate_bintval $wl_vap
        generate_dtim $wl_vap
        generate_ifname $wl_vap
        generate_rrm $wl_vap
        generate_hostapd_debug_level $wl_vap
        generate_dyn_bw_rts $wl_vap
        generate_rps $wl_vap
    fi

    if [ "$wla2_ap_operation_type" = "normal_ap" ]; then
        local local_network=${wla2_bridge:-${lan_ifname}}
        local_network=${local_network#"br"}
        wl_vap="wla2"
        get_wl_section $wl_vap
        create_new_iface
        uci set wireless.${wl_section}.device=${a2_device}
        uci set wireless.${wl_section}.network=${local_network}
        uci set wireless.${wl_section}.bridge=${wla2_bridge:-${lan_ifname}}
        uci set wireless.${wl_section}.vlan_pri=${wla2_priority}
        assign_vap_option $wl_vap
        generate_cfreq2 $wl_vap
        generate_mode $wl_vap
        generate_wps $wl_vap
        generate_wps_device_name $wl_vap
        generate_ssid $wl_vap
        generate_hide_ssid $wl_vap
        generate_puren $wl_vap
        generate_doth $wl_vap
        generate_disablecoext $wl_vap
        generate_rrm $wl_vap
        generate_security $wl_vap
        generate_protocol_setting $wl_vap
        generate_acl $wl_vap
        generate_wds $wl_vap
        generate_bintval $wl_vap
        generate_dtim $wl_vap
        generate_PIN $wl_vap
        generate_hostapd_debug_level $wl_vap
        generate_ifname $wl_vap
        generate_dyn_bw_rts $wl_vap
        generate_rps $wl_vap
    fi

    if [ "$wla2_ap_bh_operation_type" != "none" ]; then
        local local_network=${wla2_bridge:-${lan_ifname}}
        local_network=${local_network#"br"}
        wl_vap="wla2_ap_bh"
        get_wl_section $wl_vap
        create_new_iface
        uci set wireless.${wl_section}.device=${a2_device}
        uci set wireless.${wl_section}.network=${local_network}
        uci set wireless.${wl_section}.bridge=${wla2_bridge:-${lan_ifname}}
        # assign_vap_option "$wl_vap"
        generate_mode $wl_vap
        generate_ssid $wl_vap
        generate_security $wl_vap
        generate_wps $wl_vap
        generate_hide_ssid $wl_vap
        generate_disablecoext $wl_vap
        generate_protocol_setting $wl_vap
        generate_bintval $wl_vap
        # generate_PIN $wl_vap
        generate_ifname $wl_vap
        generate_hostapd_debug_level $wl_vap
        generate_dyn_bw_rts $wl_vap
        generate_rps $wl_vap
        generate_doth $wl_vap
    fi

    if [ "$wla2_sta_operation_type" != "none" ]; then
        local local_network=${wla2_bridge:-${lan_ifname}}
        local_network=${local_network#"br"}
        wl_vap="wla2_sta"
        get_wl_section $wl_vap
        create_new_iface
        uci set wireless.${wl_section}.device=${a2_device}
        uci set wireless.${wl_section}.network=${local_network}
        uci set wireless.${wl_section}.bridge=${wla2_bridge:-${lan_ifname}}
        generate_mode $wl_vap
        generate_ssid $wl_vap
        generate_security $wl_vap
        generate_ifname $wl_vap
        generate_wps $wl_vap
        generate_doth $wl_vap
        generate_hostapd_debug_level $wl_vap
        generate_dyn_bw_rts $wl_vap
        generate_rps $wl_vap
    fi

    uci commit wireless
    sync

fi

if [ "$update_conf" = "wigig" -o "$update_conf" = "all" ]; then
    if [ "x$wig_exist" = "xon" -a -d /sys/class/ieee80211/phy0 ]; then
        wl_vap="wig"
        get_wl_section $wl_vap
        create_new_iface
        uci set wigig.${wig_device}.type=mac80211
        generate_channel $wl_vap
        generate_hwmode $wl_vap
        generate_disabled $wl_vap
        uci set wigig.${wl_section}=wigig-iface
        uci set wigig.${wl_section}.device=${wig_device}
        uci set wigig.${wl_section}.bridge=${lan_ifname}
        generate_mode $wl_vap
        generate_ssid $wl_vap
        generate_hide_ssid $wl_vap
        generate_security $wl_vap
        generate_hostapd_debug_level $wl_vap
        if [ -x /usr/bin/readlink ]; then
            path="$(readlink -f /sys/class/ieee80211/phy0/device)"
            path="${path##/sys/devices/}"
            uci set wigig.${wig_device}.path=$path
            uci set wigig.${wig_device}.phy=phy0
        else
            macaddr=`cat /sys/class/ieee80211/${dev}/macaddress`
            uci set wigig.${wig_device}.macaddr='$macaddr'
        fi
        uci commit wigig
        sync
    fi
fi

REGULATORY_DOMAIN=FCC_ETSI
IPQ4019_BDF_DIR=/lib/firmware/IPQ4019/hw.1
QCA9984_BDF_DIR=/lib/firmware/QCA9984/hw.1
case "$country_code" in
    5001)
        REGULATORY_DOMAIN=Canada
        ;;
    5000)
        REGULATORY_DOMAIN=AU
        ;;
    458)
        REGULATORY_DOMAIN=SRRC
        ;;
    156)
        REGULATORY_DOMAIN=SRRC
        ;;
    702)
        REGULATORY_DOMAIN=SRRC
        ;;
    764)
        REGULATORY_DOMAIN=SRRC
        ;;
esac
if [ -d $IPQ4019_BDF_DIR/$REGULATORY_DOMAIN ]; then
    /bin/cp -f $IPQ4019_BDF_DIR/$REGULATORY_DOMAIN/* $IPQ4019_BDF_DIR/
    /bin/cp -f $QCA9984_BDF_DIR/$REGULATORY_DOMAIN/* $QCA9984_BDF_DIR/
else
    /bin/cp -f $IPQ4019_BDF_DIR/FCC_ETSI/* $IPQ4019_BDF_DIR/
    /bin/cp -f $QCA9984_BDF_DIR/FCC_ETSI/* $QCA9984_BDF_DIR/
fi
sync
